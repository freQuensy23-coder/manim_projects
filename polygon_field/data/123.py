# -*- coding: utf-8 -*-
"""123.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pjTrh92Z-W-_s6jt6nBbQks3vjsM5iNF
"""

import numpy as np
from numpy import linalg as LA
from numpy import arccos, sin, tanh
import matplotlib.pyplot as plt
from numba import njit
from tqdm import tqdm
from functools import cmp_to_key
import random
import time

def is_convex(points):
    n = len(points)
    if n < 3:
        return False
    prev = points[-2]
    curr = points[-1]
    next = points[0]
    direction = None
    for i in range(n):
        v1 = (curr[0] - prev[0], curr[1] - prev[1])
        v2 = (next[0] - curr[0], next[1] - curr[1])
        cross_product = v1[0] * v2[1] - v1[1] * v2[0]
        if cross_product != 0:
            if direction is None:
                direction = cross_product > 0
            elif direction != (cross_product > 0):
                return False
        prev, curr, next = curr, next, points[(i+1) % n]
    return True

def polygon_area(vertices):
    n = len(vertices)
    area = 0.0
    j = n - 1
    for i in range(n):
        area += (vertices[j][0] + vertices[i][0]) * (vertices[j][1] - vertices[i][1])
        j = i
    return abs(area / 2.0)

def is_point_inside_polygon(point, polygon):
    x0, y0 = point
    n = len(polygon)
    inside = False
    j = n - 1
    for i in range(n):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
        if ((yi > y0) != (yj > y0)) and (x0 < (xj - xi) * (y0 - yi) / (yj - yi) + xi):
            inside = not inside
        j = i
    return inside

def plot_polygon(points):
    n = len(points)
    x, y = zip(*points)
    x += (x[0],) # добавляем первую вершину в конец, чтобы замкнуть многоугольник
    y += (y[0],)
    plt.plot(x, y, '-o')
    plt.axis('equal')
    #plt.show()

def generate_polygon(n, convex=True, min_sq=3/10, force_not_convex=False):
    points = [(random.randint(0, 500), random.randint(0, 500)) for _ in range(n)]
    points.sort()
    pivot = points[0]
    points = sorted(points[1:], key=cmp_to_key(lambda p1, p2: (p1[1]-pivot[1])*(p2[0]-pivot[0]) - (p2[1]-pivot[1])*(p1[0]-pivot[0])))
    if convex and not is_convex(points):
      return generate_polygon(n, convex, min_sq)
    if polygon_area(points) < 500 * 500 * min_sq:
      return generate_polygon(n, convex, min_sq)
    if  not is_point_inside_polygon([250, 250], points):
      return generate_polygon(n, convex, min_sq)
    if force_not_convex and is_convex(points):
      return generate_polygon(n, convex, min_sq)
    return [pivot] + points

N = 500 # разрешение N*N
arr = np.array([[0. for i in range(N)] for j in range(N)])


# points = [(0, 0), (0, N-1), (5*N//6, 4*N//5), (N//5, N//2), (0, 0)]
points = generate_polygon(6, convex=False, force_not_convex=True) 
#plot_polygon(points)
points.append(points[0])

lines = []
for i in range(1, len(points)):
    lines.append((points[i-1], points[i]))

@njit
def f(x, y, x1, y1, x2, y2):
    a = ((x-x1)**2 + (y-y1)**2)**0.5
    b = ((x-x2)**2 + (y-y2)**2)**0.5
    c = ((x2-x1)**2 + (y2-y1)**2)**0.5
    
    if a == 0 or b == 0 or c == 0:
        E = np.array([0., 0.])
    else:
        angle = arccos((a**2 + b**2 - c**2)/(2*a*b))
        if sin(angle) == 0:
            return np.array([0., 0.])
            
        r = a*b*sin(angle)/c

        norm_E = 2*sin(angle/2)/r
        vec_E = (np.array([x-x1, y-y1])/a + np.array([x-x2, y-y2])/b)/2
        norm_vec_E = (vec_E[0]**2 + vec_E[1]**2)**0.5
        if norm_vec_E == 0:
            return np.array([0., 0.])
        vec_E = vec_E/norm_vec_E
        E = vec_E * norm_E
    
    return E

for x in tqdm(range(N)):
    for y in range(N):
        Es = np.array([0., 0.])
        for line in lines:
            Es += f(x, y, line[0][0], line[0][1], line[1][0], line[1][1])
#         print(Es, any(np.isnan(Es)))
        if any(np.isnan(Es)):
            arr[x][y] = 0
        else:
            arr[x][y] = LA.norm(Es)

k = 10 # для регулирования яркости(короче попробуй поизменять от 1 до 1000 и увидишь)
#plt.imshow(tanh(k*arr), cmap='hot', interpolation='nearest')
plt.rcParams['figure.figsize'] = [12, 10]
#plt.show()

steps = 10000
esp = 0
lr = 10000
point = [250, 250]

for i in tqdm(range(steps)):
    int_point = [int(point[0]), int(point[1])]

    if arr[int_point[0]][int_point[1]] <= esp:
        break
    
    grad = np.array([arr[int_point[0] + 1][int_point[1]] - arr[int_point[0]][int_point[1]],
                     arr[int_point[0]][int_point[1] + 1] - arr[int_point[0]][int_point[1]]])
    
    point[0] = point[0] - lr*grad[0]
    point[1] = point[1] - lr*grad[1]

print(point)

exprt_id = int(time.time())
arr_new = arr.copy()
arr_new[int_point[0]][int_point[1]] = 100
k = 10 # для регулирования яркости(короче попробуй поизменять от 1 до 1000 и увидишь)
plt.imshow(tanh(k*arr_new), cmap='hot', interpolation='nearest')
plt.rcParams['figure.figsize'] = [12, 10]
plt.savefig(f"high_res_{exprt_id}.jpg")
#plt.show()

ks = [10, 100, 300, 1000]

fig, ax = plt.subplots(nrows=1, ncols=len(ks), figsize=(10, 5))
for i, k in enumerate(ks):
  arr_new = arr.copy()
  arr_new[int_point[0]][int_point[1]] = 100
  ax[i].imshow(tanh(k*arr_new), cmap='hot', interpolation='nearest')
#plt.show()
fig.savefig(f"res_{exprt_id}.jpg")

import csv
def save_list(l, fname):
  # Open a file for writing
  with open(fname, 'w', newline='') as file:
      writer = csv.writer(file)

      # Write each row of the 2D list to the file
      for row in l:
          writer.writerow(row)

save_list(arr, f"data_{exprt_id}.csv")


# Get a list of all files in the directory

# Loop through the files and download the ones with .jpg and .csv extensions
#for file in files_list:
 #   if file.endswith(".jpg") or file.endswith(".csv"):
  #      files.download(os.path.join(dir_path, file))



